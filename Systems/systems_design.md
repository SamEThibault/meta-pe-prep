# Systems Design Basics
## Web Servers and Load Balancing
NGINX: open-source web server software used for reversee proxy, load balancing, and caching. It's event-driven, asynchronous, and uses master-slave architecture.

NGINX as a web server:
- serves static content

NGINX as a reverse proxy:
- forwards client requests to the appropriate backend server (or local application)

Most of the time, NGINX is used as a layer 7 (Application layer) load balancer:
- Receives requests directly from clients, and forwards them to the appropriate backend server
- It can also cache resources, and serve them directly to clients
- It can also terminate SSL/TLS connections, and forward unencrypted requests to the backend server (allowing for faster interal communication and processing times). Sometimes it's worth it and practical (in very secure environments), but usually you'd want to have SSL/TLS end-to-end.

Let's not forget there's also Apache, which came first. It's a bit more feature-rich, but it's not as fast as NGINX. It's also more resource-intensive.

BTW, you can also use layer 4 load balancers, which direct traffic based on IP address and port number and don't need to consider the actual content of the request.

#### Static vs Dynamic Content Delivery
Static Content: content that doesn't change often, like images, CSS, and JavaScript files. It's served directly to the client by the web server (or in most cases, cached and sent by the CDN).

Dynamic Content: content that changes often, like user-generated content, or content that needs to be generated on-the-fly. It's generated by the application server, and then served to the client.

## CDNs
Content Delivery Network: Service that accelerates internet content delivery.

Scenario: we have users all over the world, but our servers are not as distributed. 

We want to physically reduce the distance between the user and server delivering the content. So we place content delivery endpoints in as many locations as possible, these cache whatever content we would originally serve from the server. And the users can query the CDNs directly, drastically reducing round trip delays, and reducing the load on the main server.

These are used for data-heavy aplication. A CDN can delivers both static and dynamic content. Static content is cached, while dynamic content requires CDNs to reconnect with the origin server for each request. But they accelerate the delivery process by optimizing the connection between themselves and the origin servers, as oppposed to the user connecting directly to the origin server. When going through CDNs, you don't need to establish a new connection for each request, that's already assumed to be completed and ready for transmissions. You can also take advantage of your Edge CDN servers to validate user requests.

## In-memory Caches
Redis: in-memory data store (key-val). Traditionally used as a caching layer serverside, data stored in RAM (fast). Stores frequently sent requests to reduce DB loads. 

## Browser Caches
On-device storing of static web content. Browsers store these files until their time to live (TTL) expires or until the hard drive cache is full. 

## Distributed Systems
A collection of computer programs that utilize computational resources across multiple separate nodes to achieve a common, shared goal.

They aim to achieve:
- Scalability (ability to handle increased load)
- Fault Tolerance (ability to handle failures)
- Concurrency (Components operate simultaneously and independently)
- No Single Point of Failure (if one component fails, the system can still operate)

CAP Theorem:
- Consistency: all nodes see the same data simultaneously
- Availability: Every request receives a response, even if some nodes are down
- Partition Tolerance: The system continues to operate despite network partitions

Data Replication:
- Data is copied across multiple nodes to improve reliability and performance
- There's multiple replication techniques:
    - Leader-Follower replication: One node handles writes, other nodes replicate data
    - Multi-Leader replication: Multiple leaders handle writes: conflict resolution is needed
    - Eventual Consistency: Data becomes consistent over time

Sharding:
- We divide data across multiple nodes based on a shard key (user ID, for ex)
- Horizontal Scaling: each node stores a subset of data

There's both local and global caching with distributed systems:
- Local: Redis, on a single node
- Global: CDNs like Cloudflare that service multiple nodes

Distributed System Architectures:
- Client-Server: Clients request resources from a central server
- Peer-to-Peer: Nodes are both clients and servers, sharing resources directly
- Master-Slave: A master node manages one or more slave nodes
- Microservices: Application is dividedd into small, independently deployable services
- Even-Driven: Components communicate by emitting and consuming events

Best Practices:
- Assume nodes will fail, use retries, replication, and fallbacks
- Ensure repeated operations don't cause unintended side effects
- Use tools like Promehteus and Grafana for observability
- Simulate failures to ensure resilience in production


